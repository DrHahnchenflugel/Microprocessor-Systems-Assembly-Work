; FINAL PROJECT: EEBOT MAZE RUNNER
; *****************************************************************
; * This stationery serves as the framework for a                 *
; * user application (single file, absolute assembly application) *
; * For a more comprehensive program that                         *
; * demonstrates the more advanced functionality of this          *
; * processor, please see the demonstration applications          *
; * located in the examples subdirectory of the                   *
; * Freescale CodeWarrior for the HC12 Program directory          *
; *****************************************************************

              XDEF Entry, _Startup ;
              ABSENTRY Entry ; for absolute assembly: mark
              INCLUDE "derivative.inc"
;31671
;***************************************************************************************************
; equates section
;***************************************************************************************************

; Liquid Crystal Display Equates
;-------------------------------
CLEAR_HOME    EQU   $01                   ; Clear the display and home the cursor
INTERFACE     EQU   $38                   ; 8 bit interface, two line display
CURSOR_OFF    EQU   $0C                   ; Display on, cursor off
SHIFT_OFF     EQU   $06                   ; Address increments, no character shift
LCD_SEC_LINE  EQU   64                    ; Starting addr. of 2nd line of LCD (note decimal value!)

; LCD Addresses
; -------------
LCD_CNTR      EQU   PTJ                   ; LCD Control Register: E = PJ7, RS = PJ6
LCD_DAT       EQU   PORTB                 ; LCD Data Register: D7 = PB7, ... , D0 = PB0
LCD_E         EQU   $80                   ; LCD E-signal pin
LCD_RS        EQU   $40                   ; LCD RS-signal pin

; Other codes
; -----------
NULL          EQU   00                    ; The string ?null terminator?
CR            EQU   $0D                   ; ?Carriage Return? character
SPACE         EQU   ' '                   ; The ?space? character

;Timers
;---------------
T_LEFT        EQU   8
T_RIGHT       EQU   8
T_SPEED_ON    EQU   1
T_TURN_AROUND EQU   9999
T_TURN_90     EQU   9000
T_FWD_OVER_INTERSECTION EQU 9999
T_INTERSECTION_DBL_CNT  EQU 50

; States for robot
;-----------------
START         EQU   0
FWD           EQU   1
ALL_STOP      EQU   2
LEFT_TRN      EQU   3
RIGHT_TRN     EQU   4
REV_TRN       EQU   5
LEFT_ALIGN    EQU   6
RIGHT_ALIGN   EQU   7

; Intersections
;----------------
MAX_INTERS    EQU   8

DIR_N         EQU   0
DIR_E         EQU   1
DIR_S         EQU   2
DIR_W         EQU   3
DIR_NONE      EQU   4

MODE_SEARCH   EQU   0
MODE_BACK     EQU   1
MODE_REVERSE  EQU   2
MODE_TRACEBACK EQU  3

; variable/data section
; ---------------------
              ORG   $3800

; Initial values based on the initial readings & variance
; -------------------------------------------------------
BASE_LINE     FCB   $85
BASE_BOW      FCB   $A5
BASE_PORT     FCB   $8F
BASE_MID      FCB   $4F
BASE_STBD     FCB   $8E

LINE_VARIANCE           FCB   $27           ; Adding variance based on testing to
BOW_VARIANCE            FCB   $13           ; Establish baseline for sensors
PORT_VARIANCE           FCB   $1E
MID_VARIANCE            FCB   $1A
STARBOARD_VARIANCE      FCB   $1F

TOP_LINE      FCC   'V:                 '; Top line of display
              FCB   NULL                    ; terminated by null

BOT_LINE      FCC   'S:                '                      ; Bottom line of display
              FCB   NULL                    ; terminated by null

CLEAR_LINE    FCC   '                  '    ; Clear the line of display
              FCB   NULL                    ; terminated by null

TEMP          RMB   1                       ; Temporary location

; Storage Registers (9S12C32 RAM space: $3800 ... $3FFF)
; ------------------------------------------------------
SENSOR_LINE   FCB   $01                     ; Storage for guider sensor readings
SENSOR_BOW    FCB   $23                     ; Initialized to test values
SENSOR_PORT   FCB   $45
SENSOR_MID    FCB   $67
SENSOR_STBD   FCB   $89
SENSOR_NUM    RMB   1

; variable section
;***************************************************************************************************
              ORG   $3850                   ; Where our TOF counter register lives
TOF_COUNTER   dc.b  0                       ; The timer, incremented at 23Hz
CRNT_STATE    dc.b  0                       ; Current state register
T_TURN        ds.b  1                       ; time to stop turning
T_FWD         ds.b  1                       ; time to stop driving over intersection
T_SPD_CNTRL   ds.b  1                       ; time to control drive speed
TEN_THOUS     ds.b  1                       ; 10,000 digit
THOUSANDS     ds.b  1                       ; 1,000 digit
HUNDREDS      ds.b  1                       ; 100 digit
TENS          ds.b  1                       ; 10 digit
UNITS         ds.b  1                       ; 1 digit
NO_BLANK      ds.b  1                       ; Used in ?leading zero? blanking by BCD2ASC
HEX_TABLE     FCC   '0123456789ABCDEF'    ; Table for converting values
BCD_SPARE     RMB   2
LAST_PWM      dc.b  0
LAST_INTERSECTION dc.b  0

; Sensor Values
; ---------------
DETECTED_BOW     RMB   1
DETECTED_PORT    RMB   1
DETECTED_STBD    RMB   1
DETECTED_MID     RMB   1
DETECTED_LINE_LEFT  RMB   1
DETECTED_LINE_RIGHT RMB   1

; Intersections
; ---------------
HEADING       RMB   1
DRIVE_MODE    RMB   1
INTERSECT_NUM RMB   1

PATH_DIR      RMB   MAX_INTERS
REV_PATH_DIR  RMB   MAX_INTERS



; code section
;***************************************************************************************************
              ORG   $4000
Entry:
_Startup:

              LDS   #$4000                 ; Initialize the stack pointer
              CLI                          ; Enable interrupts
              JSR   INIT                   ; Initialize ports
              JSR   openADC                ; Initialize the ATD - TODO, this might not be needed due to initAD call. This has a different definition. (4 on AN1, certain prescale)
              JSR   initLCD                ; Initialize the LCD
              JSR   CLR_LCD_BUF            ; Write ?space? characters to the LCD buffer
              BSET  DDRA,%00000011         ; STAR_DIR, PORT_DIR
              BSET  DDRT,%00110000         ; STAR_SPEED, PORT_SPEED
              JSR   initAD                 ; Initialize ATD converter - 8 conversion sequence, different prescale to openADC, AN2/AN3 are digital inputs
              JSR   initLCD                ; Initialize the LCD
              JSR   clrLCD                 ; Clear LCD & home cursor
              LDX   #msg1                  ; Display msg1
              JSR   putsLCD                ;       "
              LDAA  #$C0                   ; Move LCD cursor to the 2nd row
              JSR   cmd2LCD                ;
              LDX   #msg2                  ; Display msg2
              JSR   putsLCD                ;       "

              JSR   SENSOR_FLAGS_INIT      ; Initialize sensor detected flags to 0

              LDAA #0 ; INITIAL HEADING NORTH
              STAA HEADING
              STAA INTERSECT_NUM
              STAA DRIVE_MODE
              LDAA  #START
              STAA  CRNT_STATE
              LDX   #PATH_DIR
              LDAA  #DIR_NONE
              STAA  0,X
              STAA  1,X
              STAA  2,X
              STAA  3,X
              STAA  4,X
              STAA  5,X
              STAA  6,X
              STAA  7,X
              
              
              LDX   #REV_PATH_DIR
              LDAA  #DIR_NONE
              STAA  0,X
              STAA  1,X
              STAA  2,X
              STAA  3,X
              STAA  4,X
              STAA  5,X
              STAA  6,X
              STAA  7,X
              


              JSR   INIT_STOP

              JSR   ENABLE_TOF             ; Jump to TOF initialization

              LDAA  TOF_COUNTER
              ;ADDA  #T_SPEED_ON
              ;STAA  T_SPD_CNTRL
              STAA  LAST_PWM
              STAA  LAST_INTERSECTION
              


MAIN
              JSR   G_LEDS_ON              ; Enable the guider LEDs
              JSR   READ_SENSORS           ; Read the 5 guider sensors
              JSR   G_LEDS_OFF             ; Disable the guider LEDs
              JSR   SENSOR_UPDATE           ; Update sensor detected flags
              JSR   UPDT_DISPL
              LDAA  CRNT_STATE
              JSR   DISPATCHER
              JSR   PWM_UPDATE
              BRA   MAIN

; data section
;***************************************************************************************************
msg1          dc.b  "V: ",0         ; TODO - write to LCD is wrong (in theory ignores the first byte? so add a space or smt and check.)
msg2          dc.b  "S:",0
tab           dc.b  "waiting",0
              dc.b  "forward",0
              dc.b  "all_stp",0
              dc.b  "lft_trn",0
              dc.b  "rgt_trn",0
              dc.b  "rev_trn",0
              dc.b  "lft_tmd",0
              dc.b  "rgt_tmd",0
tab_heading   dc.b  'N','E','S','W','X' 
tab_drivemode dc.b  'S','B','R'

; subroutine section
;***************************************************************************************************
DISPATCHER        JSR   VERIFY_START                        ; Start of the Dispatcher
                  RTS

VERIFY_START      CMPA  #START                                ; Verify if the robot's state is START
                  BNE   VERIFY_FORWARD                      ; If not, move to FORWARD state validation
                  JSR   START_ST                              ; Validate START state
                  RTS

VERIFY_FORWARD    CMPA  #FWD                                  ; Verify if the robot's state is FORWARD
                  BNE   VERIFY_REV_TRN                         ; If not, move to VERIFY_REV_TRN state validation
                  JSR   FWD_ST                                ; Validate FORWARD state
                  RTS

VERIFY_REV_TRN    CMPA  #REV_TRN                              ; Verify if the robot's state is REV_TURN
                  BNE   VERIFY_STOP                   ; If not, move to LEFT_ALIGN state validation
                  JSR   REV_TRN_ST                            ; Validate REV_TURN state
                  RTS

VERIFY_STOP       CMPA  #ALL_STOP                             ; Verify if the robot's state is ALL_STOP
                  BNE   VERIFY_LEFT_TRN                     ; If not, move to LEFT_TURN state validation
                  JSR   ALL_STOP_ST                           ; Validate ALL_STOP state
                  RTS

VERIFY_LEFT_TRN   CMPA  #LEFT_TRN                             ; Verify if the robot's state is LEFT_TURN
                  BNE   VERIFY_LEFT_ALIGN                    ; If not, move to RIGHT_TURN state validation
                  JSR   LEFT                                  ; Validate LEFT_TURN state
                  RTS

VERIFY_LEFT_ALIGN CMPA  #LEFT_ALIGN                         ; Verify if the robot's state is LEFT_ALIGN
                  BNE   VERIFY_RIGHT_TRN                ; If not, move to RIGHT_ALIGN state validation
                  JSR   LEFT_ALIGN_DONE                     ; Validate LEFT_ALIGN state
                  RTS

VERIFY_RIGHT_TRN  CMPA  #RIGHT_TRN                          ; Verify if the robot's state is RIGHT_TURN
                  BNE   VERIFY_RIGHT_ALIGN                    ; If not, move to REV_TURN state validation
                  JSR   RIGHT                               ; Validate RIGHT_TURN state
                  RTS

VERIFY_RIGHT_ALIGN CMPA  #RIGHT_ALIGN                       ; Verify if the robot's state is RIGHT_ALIGN
                   BNE   DISPATCH_EXIT                     ; If not, exit dispatcher (invalid state)
                   JSR   RIGHT_ALIGN_DONE                   ; Validate RIGHT_ALIGN state
                   RTS

DISPATCH_EXIT      RTS ;INVALID STATE

;------------------------------------------------------------------
; PWM_UPDATE
; Called each main loop.
; Toggles motor enable bits on PTT every T_SPEED_ON TOF ticks.
; 50% duty, applies to all states (FWD, turns, reverse, etc.)
;------------------------------------------------------------------
PWM_UPDATE:
                  LDAA  CRNT_STATE
                  CMPA  #ALL_STOP
                  BEQ   PWM_EXIT        ; no PWM in full stop
                  CMPA  #START
                  BEQ   PWM_EXIT        ; and maybe not while waiting to start

                  ;LDAA  TOF_COUNTER
                  ;CMPA  T_SPD_CNTRL
                  ;BLO   PWM_EXIT

                  LDAA  TOF_COUNTER
                  SUBA  LAST_PWM
                  CMPA  #T_SPEED_ON
                  BLO   PWM_EXIT

                  LDAA  DDRT
                  EORA  #%00110000
                  STAA  DDRT

                  LDAA  TOF_COUNTER
                  STAA  LAST_PWM
                  ;STAA  T_SPD_CNTRL

PWM_EXIT:
                  RTS

;------------------------------------------------------------------
; SENSOR_UPDATE
; Called each loop
; Reads all 5 sensors, checks states, stores values in DETECTED_*
; Values too high are "on black", too low are "on white"
;------------------------------------------------------------------
SENSOR_UPDATE
; CHECK BOW SENSOR A - TOO HIGH = BLACK, TOO LOW = WHITE
CHECK_BOW       LDAA BASE_BOW
                ADDA BOW_VARIANCE
                CMPA SENSOR_BOW
                BLO  BOW_ON_BLACK
                BHI  BOW_ON_WHITE
BOW_ON_WHITE
                MOVB #0, DETECTED_BOW
                BRA  CHECK_MID
BOW_ON_BLACK
                MOVB #1, DETECTED_BOW
                BRA  CHECK_MID

; CHECK MID SENSOR C - TOO HIGH = BLACK, TOO LOW = WHITE
CHECK_MID       LDAA BASE_MID
                ADDA MID_VARIANCE
                CMPA SENSOR_MID
                BLO  MID_ON_BLACK
                BHI  MID_ON_WHITE
MID_ON_WHITE
                MOVB #0, DETECTED_MID
                BRA  CHECK_PORT
MID_ON_BLACK
                MOVB #1, DETECTED_MID
                BRA  CHECK_PORT

; CHECK PORT SENSOR B - TOO HIGH = BLACK, TOO LOW = WHITE
CHECK_PORT      LDAA BASE_PORT
                ADDA PORT_VARIANCE
                CMPA SENSOR_PORT
                BLO  PORT_ON_BLACK
                BHI  PORT_ON_WHITE
PORT_ON_WHITE
                MOVB #0, DETECTED_PORT
                BRA  CHECK_STBD
PORT_ON_BLACK
                MOVB #1, DETECTED_PORT
                BRA  CHECK_STBD

; CHECK STBD SENSOR D - TOO HIGH = BLACK, TOO LOW = WHITE
CHECK_STBD      LDAA BASE_STBD
                ADDA STARBOARD_VARIANCE
                CMPA SENSOR_STBD
                BLO  STBD_ON_BLACK
                BHI  STBD_ON_WHITE
STBD_ON_WHITE
                MOVB #0, DETECTED_STBD
                BRA  CHECK_LINE
STBD_ON_BLACK
                MOVB #1, DETECTED_STBD
                BRA  CHECK_LINE

; CHECK LINE DIFF PAIR E/F
;   SENSOR E is on the left
;   SENSOR F is on the right
;   TOO HIGH = F on black (too far left)
;   TOO LOW  = E on black (too far right)
;   ELSE     = no significant difference
; WE SAY:
;   VAL < BASE - VAR = TOO LEFT
;   VAL > BASE + VAR = TOO RIGHT
CHECK_LINE      LDAA BASE_LINE
                ADDA LINE_VARIANCE
                CMPA SENSOR_LINE
                BLO  F_ON_BLACK
                BHS  F_ON_WHITE
F_ON_BLACK
                MOVB #1, DETECTED_LINE_RIGHT
                MOVB #0, DETECTED_LINE_LEFT
                BRA  DONE_SENSOR_UPDATE

F_ON_WHITE
                LDAA BASE_LINE
                SUBA LINE_VARIANCE
                CMPA SENSOR_LINE
                BLS  E_ON_WHITE
                BHI  E_ON_BLACK

E_ON_BLACK
                MOVB #0, DETECTED_LINE_RIGHT
                MOVB #1, DETECTED_LINE_LEFT
                BRA  DONE_SENSOR_UPDATE

E_ON_WHITE
                MOVB #0, DETECTED_LINE_RIGHT
                MOVB #0, DETECTED_LINE_LEFT
                BRA     DONE_SENSOR_UPDATE

DONE_SENSOR_UPDATE
                RTS



;Movement
;***************************************************************************************************
START_ST          BRSET   PORTAD0, $04, RELEASE                                    ;TODO - #$04?
                  LDY     #9999
                  JSR     del_50us
                  JSR     INIT_FWD
                  MOVB    #FWD, CRNT_STATE

RELEASE           ; SKIP FWD PATH FOR DEBUGGING
                  BRSET   PORTAD0, $08, RELEASE_REAR
                  ; ---------- PATH_DIR = 4,1,1,0,3,0,3,0 ----------
                  MOVB    #4, PATH_DIR
                  MOVB    #1, PATH_DIR+1
                  MOVB    #1, PATH_DIR+2
                  MOVB    #0, PATH_DIR+3
                  MOVB    #3, PATH_DIR+4
                  MOVB    #0, PATH_DIR+5
                  MOVB    #3, PATH_DIR+6
                  MOVB    #0, PATH_DIR+7

                  ; ---------- REV_PATH_DIR = 4,0,1,1,0,3,0,3 ----------
                  MOVB    #4, REV_PATH_DIR
                  MOVB    #0, REV_PATH_DIR+1
                  MOVB    #1, REV_PATH_DIR+2
                  MOVB    #1, REV_PATH_DIR+3
                  MOVB    #0, REV_PATH_DIR+4
                  MOVB    #3, REV_PATH_DIR+5
                  MOVB    #0, REV_PATH_DIR+6
                  MOVB    #3, REV_PATH_DIR+7
                  
                  MOVB    #MODE_REVERSE, DRIVE_MODE              ; if true, enter the
                  MOVB    #START, CRNT_STATE
                  MOVB    #7, INTERSECT_NUM
                  MOVB    #DIR_S, HEADING 
                  
                  BSET    DDRT, %00110000
                  JSR     INIT_STOP                           ; ALL_STOP state
                  
                  LBRA    EXIT      
RELEASE_REAR
                  RTS

;***************************************************************************************************
; CHECK BOW BUMPER
FWD_ST            BRSET   PORTAD0, $04, NO_FWD_BUMP           ; Checks if bow bumper is hit
                  LDAA    #MODE_BACK
                  STAA    DRIVE_MODE
                  JSR     UPDT_DISPL                          ; Update the display
                  JSR     INIT_REV
                  LDY     #6000
                  JSR     del_50us
                  MOVB    #REV_TRN, CRNT_STATE
                  LBRA    EXIT

; CHECK STERN BUMPER
NO_FWD_BUMP       BRSET   PORTAD0, $08, NO_FWD_READ_BUMP_T       ; Checks if the stern bumper - was 04, this is WRONG
                  BRA     YES_REAR_BUMP
NO_FWD_READ_BUMP_T  LBRA   NO_FWD_REAR_BUMP
YES_REAR_BUMP                  
                  LDAA    DRIVE_MODE
                  CMPA    #MODE_REVERSE
                  BEQ     IS_REVERSE
                  CMPA    #MODE_TRACEBACK
                  BEQ     IS_TRACEBACK
                  MOVB    #MODE_REVERSE, DRIVE_MODE              ; if true, enter the
                  MOVB    #START, CRNT_STATE
                  
                  BSET    DDRT, %00110000
                  JSR     INIT_RIGHT

                  LDY     #T_TURN_AROUND
                  JSR     del_50us                
                  LDY     #T_TURN_AROUND
                  JSR     del_50us
                  LDY     #T_TURN_AROUND
                  JSR     del_50us
                  LDY     #T_TURN_AROUND
                  JSR     del_50us
                  LDY     #T_TURN_AROUND
                  JSR     del_50us
                  
                  JSR     INIT_STOP                           ; ALL_STOP state
                  
                  LDAA    HEADING
                  EORA    #2
                  STAA    HEADING
                  LBRA    EXIT
                  
IS_REVERSE
                  
                  MOVB    #MODE_TRACEBACK, DRIVE_MODE              ; if true, enter the
                  MOVB    #START, CRNT_STATE
                  BSET    DDRT, %00110000
                  JSR     INIT_RIGHT

                  LDY     #T_TURN_AROUND
                  JSR     del_50us                
                  LDY     #T_TURN_AROUND
                  JSR     del_50us
                  LDY     #T_TURN_AROUND
                  JSR     del_50us
                  LDY     #T_TURN_AROUND
                  JSR     del_50us
                  LDY     #T_TURN_AROUND
                  JSR     del_50us
                  
                  JSR     INIT_STOP                           ; ALL_STOP state
                  
                  LDAA    HEADING
                  EORA    #2
                  STAA    HEADING
                  LBRA    EXIT
                  
IS_TRACEBACK
                  JSR     INIT_STOP
                  MOVB    #ALL_STOP, CRNT_STATE
                  LBRA    EXIT

; NO BUMPERS - CHECK POSITIONING
NO_FWD_REAR_BUMP
                  ; check if robot is on the line
                  ; is bow on white
                  ;LDAA     DETECTED_BOW
                  ;CMPA     #0
                  ;LBEQ     NOT_ALIGNED

                  ; is mid on white
                  LDAA     DETECTED_MID
                  CMPA     #0
                  LBEQ     NOT_ALIGNED


; ALIGNED ON THE LINE - CHECK FOR INTERSECTIONS
; If an intersection is detected, based off drive mode, update heading and path array
NO_MISALIGNMENT
                  ; check if robot port sensor is on black (left intersection)
                  LDAA    DETECTED_PORT
                  CMPA    #0
                  LBEQ    NO_LEFT_INTERSECTION
PORT_INTERSECTION
                  ; port intersection there, turn to port.
                  ; determine drive mode
                  LDAA    DRIVE_MODE
                  CMPA    #MODE_SEARCH
                  BEQ    PORT_INTERSECTION_SEARCH
                  
                  LDAA    DRIVE_MODE
                  CMPA    #MODE_REVERSE
                  LBEQ     REVERSE_MODE_INTERSECTION
                  
                  LDAA    DRIVE_MODE
                  CMPA    #MODE_TRACEBACK
                  LBEQ     TRACEBACK_MODE_INTERSECTION
                  

; Port intersection in returning mode
PORT_INTERSECTION_BACK
                  ; dont inc n, update heading of robot and array
                  ; heading of robot turned left
                  LDAA    HEADING
                  SUBA    #1
                  ANDA    #3
                  STAA    HEADING
                  BRA     DONE_HEADING_LEFT

; Port intersection in search mode
PORT_INTERSECTION_SEARCH
                  ; inc n, update heading of robot and array
                  LDAA    INTERSECT_NUM
                  INCA
                  STAA    INTERSECT_NUM
                  ; heading of robot turned left
                  LDX     #REV_PATH_DIR
                  LDAB    INTERSECT_NUM
                  ABX
                  LDAA    HEADING
                  STAA    0,X
                  
                  LDAA    HEADING
                  SUBA    #1
                  ANDA    #3
                  STAA    HEADING
                  BRA     DONE_HEADING_LEFT

                  
; Port intersection
; Turn left 90 degrees, update drive mode to search, then store heading in array
; Array position will be corresponding to whether intersection is search or back mode
DONE_HEADING_LEFT
                  ; Store the heading into array
                  LDX     #PATH_DIR
                  LDAB    INTERSECT_NUM
                  ABX
                  STAA    0,X

                  ; Set mode to search
                  LDAA    #MODE_SEARCH
                  STAA    DRIVE_MODE

                  ; Turn left 90 degrees
                  JSR     INIT_90_TURN
                  LBRA    TURN_LEFT_90_DEGREES

; NO PORT INTERSECTION - CHECK STARBOARD
; If starboard is detected, by problem statement, there is also a fwd path. drive fwd over the intersection
; and based off drive mode, update heading and path array
NO_LEFT_INTERSECTION
                  ; check stbd
                  LDAA    DETECTED_STBD
                  CMPA    #0
                  LBEQ    NO_INTERSECTION

                  ; MIGHT BE an intersection there - drive fwd a little bit and check for black on left side
                  ; if no black on left side - drive straight fwd
                  ; if black on left side - its a port turn, goto left intersection
                  JSR     INIT_FWD
                  LDY     #60
                  JSR     del_50us
                  JSR   G_LEDS_ON              ; Enable the guider LEDs
                  JSR   READ_SENSORS           ; Read the 5 guider sensors
                  JSR   G_LEDS_OFF             ; Disable the guider LEDs
                  JSR   SENSOR_UPDATE           ; Update sensor detected flags
                  
                  LDAA  DETECTED_PORT
                  CMPA  #1
                  LBEQ  PORT_INTERSECTION                      
                  
                  LDAA    DRIVE_MODE
                  CMPA    #MODE_SEARCH
                  LBEQ    STBD_INTERSECTION_SEARCH
                  LDAA    DRIVE_MODE
                  CMPA    #MODE_REVERSE
                  LBEQ    REVERSE_MODE_INTERSECTION
                  LDAA    DRIVE_MODE
                  CMPA    #MODE_TRACEBACK
                  LBEQ     TRACEBACK_MODE_INTERSECTION

; Starboard intersection in back mode (no chg to heading or array)
STBD_INTERSECTION_BACK
                  LBRA     DONE_HEADING_RIGHT

; Starboard intersection in search mode
STBD_INTERSECTION_SEARCH
                  ; inc n, update heading of robot and array
                  LDAA    INTERSECT_NUM
                  INCA
                  STAA    INTERSECT_NUM
                  
                  LDX     #REV_PATH_DIR
                  LDAB    INTERSECT_NUM
                  ABX
                  LDAA    HEADING
                  STAA    0,X
                  
                  LBRA     DONE_HEADING_RIGHT
                  
; Starboard intersection
; Go fwd, update drive mode to search, then store heading in array
; Array position will be corresponding to whether intersection is search or back mode
DONE_HEADING_RIGHT
                  ; store the heading into array
                  LDAA    HEADING
                  LDX     #PATH_DIR
                  LDAB    INTERSECT_NUM
                  ABX
                  STAA    0,X

                  ; Set mode to search
                  LDAA    #MODE_SEARCH
                  STAA    DRIVE_MODE

                  ; Drive fwd over intersection
                  JSR     INIT_FWD_OVER_INTERSECTION
                  LBRA     GO_FWD_OVER_INTERSECTION

; NO INTERSECTIONS - CHECK ALIGNMENT
NO_INTERSECTION
                  ; If right line on black (too far left), go to Check Right Align
                  LDAA    DETECTED_LINE_RIGHT
                  CMPA    #1
                  LBEQ    CHECK_RIGHT_ALIGN

                  ; If left line on black (too far right), go to Check Left Align
                  LDAA    DETECTED_LINE_LEFT
                  CMPA    #1
                  LBEQ    CHECK_LEFT_ALIGN

                  ;Exit condition
                  LBRA    EXIT

REVERSE_MODE_INTERSECTION
                  
                  LDX    #REV_PATH_DIR
                  LDAB   INTERSECT_NUM
                  ABX
                  LDAA   0,X ;load reverse path direction for current intersection
                  
                  EORA   #2 ; flip reverse path direction so its valid
                  
                  LDAB  HEADING      ; B = current
                  SBA            ; A = desired - current  (can be -3..+3)
                  ANDA  #$03         ; A = (desired - current) mod 4  => 0..3
                                         
                  DEC   INTERSECT_NUM

                  CMPA  #0
                  BNE   NOT_FWD_REV_MODE
                  ; same direction
                  JSR   INIT_FWD_OVER_INTERSECTION
                  LBRA  GO_FWD_OVER_INTERSECTION
NOT_FWD_REV_MODE
                  CMPA  #1
                  BNE   NOT_RIGHT_REV_MODE
                  ; desired is 1 step clockwise
                  ; Turn left 90 degrees
                  LDAA    HEADING
                  SUBA    #1
                  ANDA    #3
                  SUBA    #1
                  ANDA    #3
                  STAA    HEADING
                  
                  JSR     INIT_90_TURN_RIGHT
                  LBRA    TURN_RIGHT_90_DEGREES

                  
                  
NOT_RIGHT_REV_MODE
                  ; desired is 1 step counter-clockwise (-1 mod 4)
                  ; Turn left 90 degrees
                  LDAA    HEADING
                  SUBA    #1
                  ANDA    #3
                  STAA    HEADING
                  
                  JSR     INIT_90_TURN
                  LBRA    TURN_LEFT_90_DEGREES

                  
                  

TRACEBACK_MODE_INTERSECTION
                  LDX     #PATH_DIR
                  LDAB    INTERSECT_NUM
                  ABX
                  
                  LDAA    0,X
                  
                  LDAB    HEADING
                  SBA     
                  ANDA    #$03
                  EORA    #$02
                  
                  INC     INTERSECT_NUM
                  
                  CMPA  #0
                  BNE   NOT_FW_TB_MODE
                  ; same direction
                  JSR   INIT_FWD_OVER_INTERSECTION
                  LBRA  GO_FWD_OVER_INTERSECTION
NOT_FW_TB_MODE
                  CMPA  #1
                  BNE   NOT_RIGHT_TB_MODE
                  ; desired is 1 step clockwise
                  ; Turn left 90 degrees
                  LDAA    HEADING
                  SUBA    #1
                  ANDA    #3
                  SUBA    #1
                  ANDA    #3
                  STAA    HEADING
                  
                  JSR     INIT_90_TURN_RIGHT
                  LBRA    TURN_RIGHT_90_DEGREES
NOT_RIGHT_TB_MODE

                  CMPA  #3
                  ; desired is 1 step counter-clockwise (-1 mod 4)
                  ; Turn left 90 degrees
                  JSR     INIT_90_TURN
                  LBRA    TURN_LEFT_90_DEGREES
                  LDAA    HEADING
                  SUBA    #1
                  ANDA    #3
                  STAA    HEADING
                  
                  
;***************************************************************************************************

; NOT ALIGNED TO LINE - CHECK WHICH SIDE
NOT_ALIGNED
                  ; Check port side - if that's the problem, execute partial left turn
                  LDAA    DETECTED_PORT
                  CMPA    #1
                  LBEQ    PARTIAL_LEFT_TRN

NO_PORT           ; Check starboard side - if that's the problem, execute partial right turn
                  LDAA    DETECTED_STBD
                  CMPA    #1
                  LBEQ    PARTIAL_RIGHT_TRN

NO_BOW            ; Neither port nor startboard - check bow.
                  ; If bow also on white, lost (exit)
                  ; If bow on black, do a partial right turn to re-align (chosen arbitrarily - if robot is here, it's in a bad state anyway)
                  LDAA    DETECTED_BOW
                  CMPA    #1
                  LBNE    EXIT
                  LBEQ    PARTIAL_RIGHT_TRN

;***************************************************************************************************

; EXECUTE PARTIAL TURNS - LEFT SIDE
PARTIAL_LEFT_TRN
                  ; DELAY
                  ;LDY     #600
                  LDY     #60
                  jsr     del_50us
                  ; TURN LEFT
                  JSR     INIT_LEFT

                  ; Update current display state
                  MOVB    #LEFT_TRN, CRNT_STATE
                  JSR     UPDT_DISPL

                  ; DELAY (Allow time for turn to take effect)
                  ;LDY     #600
                  LDY     #60
                  JSR     del_50us

                  ; DONE
                  LBRA     EXIT

; EXECUTE ALIGN TURN TO THE LEFT
CHECK_LEFT_ALIGN
                  ; TURN LEFT, NO DELAY
                  JSR     INIT_LEFT
                  MOVB    #LEFT_ALIGN, CRNT_STATE
                  LBRA     EXIT

;***************************************************************************************************

; EXECUTE PARTIAL TURNS - RIGHT SIDE
PARTIAL_RIGHT_TRN
                  ; DELAY
                  ;LDY     #600
                  LDY     #60
                  JSR     del_50us

                  ; TURN RIGHT
                  JSR     INIT_RIGHT
                  MOVB    #RIGHT_TRN, CRNT_STATE
                  JSR     UPDT_DISPL

                  ; DELAY (Allow time for turn to take effect)
                  ;LDY     #600
                  LDY     #60
                  JSR     del_50us

                  ; DONE
                  LBRA     EXIT

; EXECUTE ALIGN TURN TO THE RIGHT
CHECK_RIGHT_ALIGN
                  ; TURN RIGHT, NO DELAY
                  JSR     INIT_RIGHT
                  MOVB    #RIGHT_ALIGN, CRNT_STATE
                  LBRA     EXIT

;***************************************************************************************************

; ALIGNMENT SUBROUTINES

; LEFT TURN TO ALIGN UNTIL BOW SENSOR IS ON LINE
LEFT
                  LDAA    DETECTED_BOW
                  CMPA    #1
                  BEQ     LEFT_ALIGN_DONE
                  LBNE     EXIT

; LEFT ALIGN DONE (did left align once, check fwd state again)
LEFT_ALIGN_DONE
                  MOVB    #FWD, CRNT_STATE
                  JSR     INIT_FWD
                  LBRA     EXIT

; RIGHT TURN TO ALIGN UNTIL BOW SENSOR IS ON LINE
RIGHT
                  LDAA    DETECTED_BOW
                  CMPA    #1
                  BEQ     RIGHT_ALIGN_DONE
                  LBNE     EXIT

; RIGHT ALIGN DONE (did right align once, check fwd state again)
RIGHT_ALIGN_DONE  MOVB    #FWD, CRNT_STATE
                  JSR     INIT_FWD
                  LBRA     EXIT

;***************************************************************************************************

; OTHER MOVEMENT STATES
; REVERSE TURN AND ALL STOP STATES

; Reverse turn
REV_TRN_ST
                  ; IF TOF COUNTER < T_TURN, KEEP REVERSING
                  ;LDAA    TOF_COUNTER               ; Mark the fwd_turn time Tfwdturn
                  ;CMPA    T_TURN
                  ;BLT     EXIT

                  BSET    DDRT, %00110000
                  JSR     INIT_RIGHT

                  LDY     #T_TURN_AROUND
                  JSR     del_50us                
                  LDY     #T_TURN_AROUND
                  JSR     del_50us
                  LDY     #T_TURN_AROUND
                  JSR     del_50us
                  LDY     #T_TURN_AROUND
                  JSR     del_50us
                  LDY     #T_TURN_AROUND
                  JSR     del_50us
                  
                  ; IF TOF COUNTER >= T_TURN, FINISH REVERSING AND UPDATE HEADING
                  MOVB    #FWD, CRNT_STATE
                  JSR     INIT_FWD

                  ; Reverse heading
                  LDAA    HEADING
                  EORA    #2        ;XOR by 0010, flip heading
                  STAA    HEADING
                  LBRA     EXIT

; All stop (TODO - add condition to exit all stop)
ALL_STOP_ST
                  LBRA     EXIT

;***************************************************************************************************

; MEASURED MOVEMENT STATES FOR INTERSECTIONS

; LEFT TURN 90 DEGREES
TURN_LEFT_90_DEGREES
                  ; IF TOF COUNTER < T_TURN, KEEP TURNING LEFT
                  ;LDAA    TOF_COUNTER               ; Mark the fwd_turn time Tfwdturn
                  ;CMPA    T_TURN
                  ;BLT     EXIT
                  ; IF TOF COUNTER >= T_TURN, FINISH LEFT TURN
                  BSET    DDRT, %00110000
                  JSR     INIT_FWD
                  LDY     #T_TURN_90
                  JSR     del_50us
                  LDY     #T_TURN_90
                  JSR     del_50us
                  
                  JSR     INIT_LEFT
                  LDY     #T_TURN_90
                  JSR     del_50us
                  LDY     #T_TURN_90
                  JSR     del_50us
                  LDY     #T_TURN_90
                  JSR     del_50us
                  
                  MOVB    #FWD, CRNT_STATE
                  JSR     INIT_FWD
                  BRA     EXIT


; RIGHT TURN 90 DEGREES
TURN_RIGHT_90_DEGREES
                  BSET    DDRT, %00110000
                  JSR     INIT_FWD
                  LDY     #T_TURN_90
                  JSR     del_50us
                  LDY     #T_TURN_90
                  JSR     del_50us
                  
                  JSR     INIT_RIGHT
                  LDY     #T_TURN_90
                  JSR     del_50us
                  LDY     #T_TURN_90
                  JSR     del_50us
                  LDY     #T_TURN_90
                  JSR     del_50us
                  
                  MOVB    #FWD, CRNT_STATE
                  JSR     INIT_FWD
                  BRA     EXIT

; GO FWD OVER INTERSECTION
GO_FWD_OVER_INTERSECTION
                  ; IF TOF COUNTER < T_FWD, KEEP DRIVING FWD
                  ;LDAA    TOF_COUNTER               ; Mark the fwd_turn time Tfwdturn
                  ;CMPA    T_FWD
                  ;BLT     EXIT
                  ; IF TOF COUNTER >= T_FWD, FINISH DRIVING FWD OVER INTERSECTION, BACK TO LINE FOLLOWING
                  BSET    DDRT, %00110000
                  JSR     INIT_FWD
                  LDY     #T_FWD_OVER_INTERSECTION
                  JSR     del_50us
                  
                  LDY     #T_FWD_OVER_INTERSECTION
                  JSR     del_50us
                  
                  MOVB    #FWD, CRNT_STATE
                  JSR     INIT_FWD
                  BRA     EXIT

; EXIT - END OF SUBROUTINE
EXIT
                  RTS


; Initialization Subroutines
;***************************************************************************************************
; Run once @ beginning of pgm - set all detected values to 0.
SENSOR_FLAGS_INIT:
        MOVB  #0, DETECTED_BOW
        MOVB  #0, DETECTED_PORT
        MOVB  #0, DETECTED_STBD
        MOVB  #0, DETECTED_MID
        MOVB  #0, DETECTED_LINE_LEFT
        MOVB  #0, DETECTED_LINE_RIGHT
        RTS

; Initialise right turn
INIT_RIGHT        BSET    PORTA,%00000010
                  BCLR    PORTA,%00000001
                  BSET    PTT, %00110000            ; Turn on the drive motors
                  LDAA    TOF_COUNTER               ; Mark the fwd_turn time Tfwdturn
                  ADDA    #T_RIGHT
                  STAA    T_TURN
                  RTS

; Initialise left turn
INIT_LEFT         BSET    PORTA,%00000001
                  BCLR    PORTA,%00000010
                  BSET    PTT, %00110000            ; Turn on the drive motors
                  LDAA    TOF_COUNTER               ; Mark TOF time
                  ADDA    #T_LEFT                   ; Add left turn
                  STAA    T_TURN
                  RTS

; Initialise forward movement
INIT_FWD          BCLR    PORTA, %00000011          ; Set FWD dir. for both motors
                  BSET    PTT, %00110000            ; Turn on the drive motors
                  RTS

; Initialise reverse movement
INIT_REV          BSET PORTA,%00000011              ; Set REV direction for both motors
                  BSET PTT,%00110000                ; Turn on the drive motors
                  RTS

; Initialise reverse turn
INIT_REV_TURN     BSET    PORTA,%00000010
                  BCLR    PORTA,%00000001
                  BSET    PTT, %00110000            ; Turn on the drive motors
                  ;LDAA    TOF_COUNTER               ; Mark the fwd_turn time Tfwdturn
                  ;ADDA    #T_TURN_AROUND
                  ;STAA    T_TURN
                  RTS

; Initialize 90 degree turn
INIT_90_TURN      BSET    PORTA,%00000001
                  BCLR    PORTA,%00000010
                  BSET    PTT, %00110000            ; Turn on the drive motors
                  RTS


; Initialize 90 degree turn right
INIT_90_TURN_RIGHT      BSET    PORTA,%00000010
                  BCLR    PORTA,%00000001
                  BSET    PTT, %00110000            ; Turn on the drive motors
                  RTS

; Initialize forward over intersection
INIT_FWD_OVER_INTERSECTION
                  JSR     INIT_FWD
                  ;LDAA    TOF_COUNTER               ; Mark the fwd_turn time Tfwdturn
                  ;ADDA    #T_FWD_OVER_INTERSECTION
                  ;STAA    T_FWD
                  RTS

; Initialize stop (all motors off)
INIT_STOP         BCLR    PTT, %00110000            ; Turn off the drive motors
                  RTS


;***************************************************************************************************
;       Initialize Sensors
INIT              BCLR   DDRAD,$FF ; Make PORTAD an input (DDRAD @ $0272)
                  BSET   DDRA,$FF  ; Make PORTA an output (DDRA @ $0002)
                  BSET   DDRB,$FF  ; Make PORTB an output (DDRB @ $0003)
                  BSET   DDRJ,$C0  ; Make pins 7,6 of PTJ outputs (DDRJ @ $026A)
                  RTS


;***************************************************************************************************
;        Initialize ADC
openADC           MOVB   #$80,ATDCTL2 ; Turn on ADC (ATDCTL2 @ $0082)
                  LDY    #1           ; Wait for 50 us for ADC to be ready
                  JSR    del_50us     ; - " -
                  MOVB   #$20,ATDCTL3 ; 4 conversions on channel AN1 (ATDCTL3 @ $0083)
                  MOVB   #$97,ATDCTL4 ; 8-bit resolution, prescaler=48 (ATDCTL4 @ $0084)
                  RTS

;---------------------------------------------------------------------------
;                           Clear LCD Buffer
; This routine writes ?space? characters (ascii 20) into the LCD display
; buffer in order to prepare it for the building of a new display buffer.
; This needs only to be done once at the start of the program. Thereafter the
; display routine should maintain the buffer properly.
CLR_LCD_BUF       LDX   #CLEAR_LINE
                  LDY   #TOP_LINE
                  JSR   STRCPY

CLB_SECOND        LDX   #CLEAR_LINE
                  LDY   #BOT_LINE
                  JSR   STRCPY

CLB_EXIT          RTS

; -------------------------------------------------------------------------------------------------
; String Copy
; Copies a null-terminated string (including the null) from one location to
; another
; Passed: X contains starting address of null-terminated string
; Y contains first address of destination
STRCPY            PSHX            ; Protect the registers used
                  PSHY
                  PSHA

STRCPY_LOOP       LDAA 0,X        ; Get a source character
                  STAA 0,Y        ; Copy it to the destination
                  BEQ STRCPY_EXIT ; If it was the null, then exit
                  INX             ; Else increment the pointers
                  INY
                  BRA STRCPY_LOOP ; and do it again

STRCPY_EXIT       PULA            ; Restore the registers
                  PULY
                  PULX
                  RTS

; -------------------------------------------------------------------------------------------------
;                                   Guider LEDs ON                                                 |
; This routine enables the guider LEDs so that readings of the sensor                              |
; correspond to the ?illuminated? situation.                                                       |
; Passed: Nothing                                                                                  |
; Returns: Nothing                                                                                 |
; Side: PORTA bit 5 is changed                                                                     |
G_LEDS_ON         BSET PORTA,%00100000 ; Set bit 5                                                 |
                  RTS                                                                             ;|

; -------------------------------------------------------------------------------------------------
;                                   Guider LEDs OFF                                                |
; This routine disables the guider LEDs. Readings of the sensor                                    |
; correspond to the ?ambient lighting? situation.                                                  |
; Passed: Nothing                                                                                  |
; Returns: Nothing                                                                                 |
; Side: PORTA bit 5 is changed                                                                     |
G_LEDS_OFF        BCLR PORTA,%00100000 ; Clear bit 5                                               |
                  RTS                                                                             ;|

; -------------------------------------------------------------------------------------------------
;                               Read Sensors

READ_SENSORS      CLR   SENSOR_NUM     ; Select sensor number 0
                  LDX   #SENSOR_LINE   ; Point at the start of the sensor array

RS_MAIN_LOOP      LDAA  SENSOR_NUM     ; Select the correct sensor input
                  JSR   SELECT_SENSOR  ; on the hardware
                  LDY   #400           ; 20 ms delay to allow the
                  JSR   del_50us       ; sensor to stabilize
                  LDAA  #%10000001     ; Start A/D conversion on AN1
                  STAA  ATDCTL5
                  BRCLR ATDSTAT0,$80,* ; Repeat until A/D signals done
                  LDAA  ATDDR0L        ; A/D conversion is complete in ATDDR0L
                  STAA  0,X            ; so copy it to the sensor register
                  CPX   #SENSOR_STBD   ; If this is the last reading
                  BEQ   RS_EXIT        ; Then exit
                  INC   SENSOR_NUM     ; Else, increment the sensor number
                  INX                  ; and the pointer into the sensor array
                  BRA   RS_MAIN_LOOP   ; and do it again

RS_EXIT           RTS


; -------------------------------------------------------------------------------------------------
;                               Select Sensor
; -------------------------------------------------------------------------------------------------
SELECT_SENSOR     PSHA                ; Save the sensor number for the moment
                  LDAA PORTA          ; Clear the sensor selection bits to zeros
                  ANDA #%11100011
                  STAA TEMP           ; and save it into TEMP
                  PULA                ; Get the sensor number
                  ASLA                ; Shift the selection number left, twice
                  ASLA
                  ANDA #%00011100     ; Clear irrelevant bit positions
                  ORAA TEMP           ; OR it into the sensor bit positions
                  STAA PORTA          ; Update the hardware
                  RTS


;***************************************************************************************************
;*                      Update Display (Battery Voltage + Current State)                           *
;***************************************************************************************************
DP_FRONT_SENSOR   EQU TOP_LINE+14
DP_LINE_SENSOR    EQU TOP_LINE+17
DP_VOLTAGE_TEN_THOU       EQU TOP_LINE+2
DP_VOLTAGE_THOU           EQU DP_VOLTAGE_TEN_THOU+1
DP_VOLTAGE_DECIMAL        EQU DP_VOLTAGE_TEN_THOU+2
DP_VOLTAGE_HUNDREDS       EQU DP_VOLTAGE_TEN_THOU+3
DP_HEADING        EQU DP_VOLTAGE_HUNDREDS+4
DP_DRIVEMODE      EQU DP_HEADING+1
DP_INTERSECT_NUM  EQU DP_DRIVEMODE+1

DP_PORT_SENSOR    EQU BOT_LINE+12
DP_MID_SENSOR     EQU BOT_LINE+15
DP_STBD_SENSOR    EQU BOT_LINE+18
DP_STATE          EQU BOT_LINE+2
DP_STATE_END      EQU DP_STATE+7

                  ;LDAA  SENSOR_BOW        ; Get the FRONT sensor value
                  ;JSR   BIN2ASC           ; Convert to ascii string in D
                  ;LDX   #DP_FRONT_SENSOR  ; Point to the LCD buffer position
                  ;STD   0,X               ; and write the 2 ascii digits there
UPDT_DISPL
                  JSR   clrLCD
                  LDAA    DRIVE_MODE
                  CMPA    #MODE_REVERSE
                  BNE    NORMAL_DISP_OP
                  LDAA    CRNT_STATE
                  CMPA    #START
                  BNE    NORMAL_DISP_OP
                  
                  LBRA  UPD_DISP_INTERSECTIONS
                  
NORMAL_DISP_OP                  
                  
                  LDAA    #'V'
                  LDAB    #':'
                  LDX     #TOP_LINE
                  STAA    0,X
                  LDX     #TOP_LINE
                  STAB    1,X

                  MOVB    #$90,ATDCTL5    ; R-just., uns., sing. conv., mult., ch=0, start
                  BRCLR   ATDSTAT0,$80,*  ; Wait until the conver. seq. is complete
                  LDAA    ATDDR0L         ; Load the ch0 result - battery volt - into A
                  LDAB    #39             ;AccB = 39
                  MUL                     ;AccD = 1st result x 39
                  ADDD    #600            ;AccD = 1st result x 39 + 600
                  JSR     int2BCD
                  JSR     BCD2ASC


                  LDAB     TEN_THOUS
                  LDX     #DP_VOLTAGE_TEN_THOU
                  STAB     0,X

                  LDAB     THOUSANDS
                  LDX     #DP_VOLTAGE_THOU
                  STAB     0,X

                  LDAB     #'.'
                  LDX      #DP_VOLTAGE_DECIMAL
                  STAB     0,X

                  LDAB     HUNDREDS
                  LDX     #DP_VOLTAGE_HUNDREDS
                  STAB     0,X

                  LDX      #tab_heading
                  LDAB     HEADING
                  ABX
                  LDAA     0,X
                  LDY      #DP_HEADING
                  STAA     0,Y

                  LDX      #tab_drivemode
                  LDAB     DRIVE_MODE
                  ABX
                  LDAA     0,X
                  LDY      #DP_DRIVEMODE
                  STAA     0,Y

                  LDAA     INTERSECT_NUM
                  ADDA     #$30
                  LDY      #DP_INTERSECT_NUM
                  STAA     0,Y


                  LDAA  SENSOR_BOW        ; Get the LEFT sensor value
                  JSR   BIN2ASC           ; Convert to ascii string in D
                  ;CLRA
                  ;LDAA  DETECTED_BOW
                  ;LDAB  DETECTED_BOW
                  LDX   #DP_FRONT_SENSOR  ; Point to the LCD buffer position
                  STD   0,X               ; and write the 2 ascii digits there

                  LDAA  SENSOR_LINE        ; Get the LEFT sensor value
                  JSR   BIN2ASC           ; Convert to ascii string in D
                  LDX   #DP_LINE_SENSOR  ; Point to the LCD buffer position
                  STD   0,X               ; and write the 2 ascii digits there

                  LDAA    #'S'
                  LDAB    #':'
                  LDX     #BOT_LINE
                  STAA    0,X
                  LDX     #BOT_LINE
                  STAB    1,X

                  LDAA    #$C2            ; Move LCD cursor to the 2nd row, end of msg2
                  JSR     cmd2LCD         ;
                  LDAB    CRNT_STATE      ; Display current state
                  LSLB                    ; "
                  LSLB                    ; "
                  LSLB
                  LDX     #tab            ; "
                  ABX                     ; "
                  LDY     #DP_STATE
                  JSR     STRCPY

                  LDAB     #' '
                  LDX      #DP_STATE_END
                  STAB     0,X

                  LDAA  SENSOR_PORT        ; Get the LEFT sensor value
                  JSR   BIN2ASC           ; Convert to ascii string in D
                  LDX   #DP_PORT_SENSOR  ; Point to the LCD buffer position
                  STD   0,X               ; and write the 2 ascii digits there

                  LDAA  SENSOR_MID        ; Get the LEFT sensor value
                  JSR   BIN2ASC           ; Convert to ascii string in D
                  LDX   #DP_MID_SENSOR  ; Point to the LCD buffer position
                  STD   0,X               ; and write the 2 ascii digits there

                  LDAA  SENSOR_STBD        ; Get the LEFT sensor value
                  JSR   BIN2ASC           ; Convert to ascii string in D
                  LDX   #DP_STBD_SENSOR  ; Point to the LCD buffer position
                  STD   0,X               ; and write the 2 ascii digits there

                  ;LDAA    #$CC             ; Move LCD to 2nd row, after state
                  ;JSR     cmd2LCD
                  ;LDD     SENSOR_PORT
                  ;JSR     BIN2ASC           ; Convert to ascii string in D
                  ;STD     0,X
                  ;JSR     putsLCD



                  LDAA    #CLEAR_HOME ; Move LCD cursor to the 1st row
                  JSR     cmd2LCD
                  LDY     #40 ; Wait 2 ms until "clear display" command is complete
                  JSR     del_50us
                  LDX     #TOP_LINE
                  JSR     putsLCD

                  LDAA    #$C0; Move LCD cursor to the 2nd row
                  JSR     cmd2LCD
                  LDY     #40 ; Wait 2 ms until "clear display" command is complete
                  JSR     del_50us
                  LDX     #BOT_LINE
                  JSR     putsLCD

                  RTS

DP_P_LABEL       EQU  TOP_LINE       ; 'P' at col 0, ':' at col 1
DP_R_LABEL       EQU  BOT_LINE       ; 'R' at col 0, ':' at col 1

DP_P_PATH_START  EQU  TOP_LINE+2     ; first direction on row 1
DP_R_PATH_START  EQU  BOT_LINE+2     ; first direction on row 2

UPD_DISP_INTERSECTIONS
        JSR     SHOW_PATHS
        LDAA    #CLEAR_HOME
        JSR     cmd2LCD
        LDY     #40
        JSR     del_50us

        LDX     #TOP_LINE
        JSR     putsLCD

        LDAA    #$C0
        JSR     cmd2LCD
        LDY     #40
        JSR     del_50us

        LDX     #BOT_LINE
        JSR     putsLCD

        RTS
;------------------------------------------------------------
; DISP_PATH_BUF
; In:
;   Y -> array of direction codes (0..4)
;   X -> destination buffer (e.g. DP_P_PATH_START)
;   B = number of elements
; Uses:
;   tab_heading: db 'N','E','S','W','X'
; Clobbers: A, B, X, Y
;------------------------------------------------------------
DISP_PATH_BUF
DPB_LOOP
        CMPB    #0
        BEQ     DPB_DONE

        ; A = code (0..3) from array
        LDAA    0,Y
        INY

        ; Map code via tab_heading using A as offset
        ; Need B temporarily as index, so save loop counter
        PSHB                ; save count

        TAB                 ; B = code (0..4)
        PSHX
        LDX     #tab_heading
        ABX                 ; X = tab_heading + B
        LDAA    0,X         ; A = 'N'/'E'/'S'/'W'
        PULX
        PULB                ; restore count to B

        ; Store letter into buffer
        STAA    0,X
        INX

        ; One element consumed
        DECB
        BEQ     DPB_DONE    ; no trailing space after last one

        ; Store space between entries
        LDAA    #' '
        STAA    0,X
        INX

        BRA     DPB_LOOP

DPB_DONE
        RTS
        
;------------------------------------------------------------
; SHOW_PATHS
; Builds:
;   Row 1: "P:" + PATH_DIR entries as N/E/S/W separated by spaces
;   Row 2: "R:" + REV_PATH_DIR entries as N/E/S/W separated by spaces
; Uses INTERSECT_NUM (0-based index of last valid entry)
;------------------------------------------------------------
SHOW_PATHS
        ; ---------------- Row 1: "P:" label ----------------
        LDX     #DP_P_LABEL
        LDAA    #'P'
        STAA    0,X
        LDAA    #':'
        STAA    1,X

        ; PATH_DIR content -> TOP_LINE starting at col 2
        LDX     #DP_P_PATH_START     ; dest buffer (row 1 path start)
        LDY     #PATH_DIR            ; source array

        LDAA    INTERSECT_NUM        ; 0..MAX_INTERS-1
        ;INCA                         ; count = last_index + 1
        TAB                          ; B = count

        JSR     DISP_PATH_BUF

        ; ---------------- Row 2: "R:" label ----------------
        LDX     #DP_R_LABEL
        LDAA    #'R'
        STAA    0,X
        LDAA    #':'
        STAA    1,X

        ; REV_PATH_DIR content -> BOT_LINE starting at col 2
        LDX     #DP_R_PATH_START
        LDY     #REV_PATH_DIR

        LDAA    INTERSECT_NUM
        INCA
        TAB

        JSR     DISP_PATH_BUF

        RTS


;***************************************************************************************************
ENABLE_TOF        LDAA    #%10000000
                  STAA    TSCR1           ; Enable TCNT
                  STAA    TFLG2           ; Clear TOF
                  LDAA    #%10000100      ; Enable TOI and select prescale factor equal to 16
                  STAA    TSCR2
                  RTS

TOF_ISR           INC     TOF_COUNTER
                  LDAA    #%10000000      ; Clear
                  STAA    TFLG2           ; TOF
                  RTI


; utility subroutines
;***************************************************************************************************
initLCD:          BSET    DDRB,%11111111  ; configure pins PS7,PS6,PS5,PS4 for output
                  BSET    DDRJ,%11000000  ; configure pins PE7,PE4 for output
                  LDY     #2000
                  JSR     del_50us
                  LDAA    #$28
                  JSR     cmd2LCD
                  LDAA    #$0C
                  JSR     cmd2LCD
                  LDAA    #$06
                  JSR     cmd2LCD
                  RTS

;***************************************************************************************************
clrLCD:           LDAA  #$01
                  JSR   cmd2LCD
                  LDY   #40
                  JSR   del_50us
                  RTS

;***************************************************************************************************
del_50us          PSHX                   ; (2 E-clk) Protect the X register
eloop             LDX   #300             ; (2 E-clk) Initialize the inner loop counter
iloop             NOP                    ; (1 E-clk) No operation
                  DBNE X,iloop           ; (3 E-clk) If the inner cntr not 0, loop again
                  DBNE Y,eloop           ; (3 E-clk) If the outer cntr not 0, loop again
                  PULX                   ; (3 E-clk) Restore the X register
                  RTS                    ; (5 E-clk) Else return

;***************************************************************************************************
cmd2LCD:          BCLR  LCD_CNTR, LCD_RS ; select the LCD instruction
                  JSR   dataMov          ; send data to IR
                  RTS

;***************************************************************************************************
putsLCD:          LDAA  1,X+             ; get one character from  string
                  BEQ   donePS           ; get NULL character
                  JSR   putcLCD
                  BRA   putsLCD

donePS            RTS

;***************************************************************************************************
putcLCD:          BSET  LCD_CNTR, LCD_RS  ; select the LCD data register (DR)c
                  JSR   dataMov           ; send data to DR
                  RTS

;***************************************************************************************************
dataMov:          BSET  LCD_CNTR, LCD_E   ; pull LCD E-signal high
                  STAA  LCD_DAT           ; send the upper 4 bits of data to LCD
                  BCLR  LCD_CNTR, LCD_E   ; pull the LCD E-signal low to complete write oper.
                  LSLA                    ; match the lower 4 bits with LCD data pins
                  LSLA                    ; ""
                  LSLA                    ; ""
                  LSLA                    ; ""
                  BSET  LCD_CNTR, LCD_E   ; pull LCD E-signal high
                  STAA  LCD_DAT           ; send the lower 4 bits of data to LCD
                  BCLR  LCD_CNTR, LCD_E   ; pull the LCD E-signal low to complete write oper.
                  LDY   #1                ; adding this delay allows
                  JSR   del_50us          ; completion of most instructions
                  RTS

;***************************************************************************************************
initAD            MOVB  #$C0,ATDCTL2      ;power up AD, select fast flag clear
                  JSR   del_50us          ;wait for 50 us
                  MOVB  #$00,ATDCTL3      ;8 conversions in a sequence
                  MOVB  #$85,ATDCTL4      ;res=8, conv-clks=2, prescal=12
                  BSET  ATDDIEN,$0C       ;configure pins AN03,AN02 as digital inputs
                  RTS

;***************************************************************************************************
int2BCD           XGDX                    ;Save the binary number into .X
                  LDAA #0                 ;Clear the BCD_BUFFER
                  STAA TEN_THOUS
                  STAA THOUSANDS
                  STAA HUNDREDS
                  STAA TENS
                  STAA UNITS
                  STAA BCD_SPARE
                  STAA BCD_SPARE+1
                  CPX #0                  ; Check for a zero input
                  BEQ CON_EXIT            ; and if so, exit
                  XGDX                    ; Not zero, get the binary number back to .D as dividend
                  LDX #10                 ; Setup 10 (Decimal!) as the divisor
                  IDIV                    ; Divide Quotient is now in .X, remainder in .D
                  STAB UNITS              ; Store remainder
                  CPX #0                  ; If quotient is zero,
                  BEQ CON_EXIT            ; then exit
                  XGDX                    ; else swap first quotient back into .D
                  LDX #10                 ; and setup for another divide by 10
                  IDIV
                  STAB TENS
                  CPX #0
                  BEQ CON_EXIT
                  XGDX                    ; Swap quotient back into .D
                  LDX #10                 ; and setup for another divide by 10
                  IDIV
                  STAB HUNDREDS
                  CPX #0
                  BEQ CON_EXIT
                  XGDX                    ; Swap quotient back into .D
                  LDX #10                 ; and setup for another divide by 10
                  IDIV
                  STAB THOUSANDS
                  CPX #0
                  BEQ CON_EXIT
                  XGDX                    ; Swap quotient back into .D
                  LDX #10                 ; and setup for another divide by 10
                  IDIV
                  STAB TEN_THOUS

CON_EXIT          RTS                     ; Were done the conversion

LCD_POS_CRSR      ORAA #%10000000         ; Set the high bit of the control word
                  JSR cmd2LCD             ; and set the cursor address
                  RTS

;***************************************************************************************************
BIN2ASC               PSHA               ; Save a copy of the input number
                      TAB
                      ANDB #%00001111     ; Strip off the upper nibble
                      CLRA                ; D now contains 000n where n is the LSnibble
                      ADDD #HEX_TABLE     ; Set up for indexed load
                      XGDX
                      LDAA 0,X            ; Get the LSnibble character
                      PULB                ; Retrieve the input number into ACCB
                      PSHA                ; and push the LSnibble character in its place
                      RORB                ; Move the upper nibble of the input number
                      RORB                ;  into the lower nibble position.
                      RORB
                      RORB
                      ANDB #%00001111     ; Strip off the upper nibble
                      CLRA                ; D now contains 000n where n is the MSnibble
                      ADDD #HEX_TABLE     ; Set up for indexed load
                      XGDX
                      LDAA 0,X            ; Get the MSnibble character into ACCA
                      PULB                ; Retrieve the LSnibble character into ACCB
                      RTS

;***************************************************************************************************
;* BCD to ASCII Conversion Routine
;* This routine converts the BCD number in the BCD_BUFFER
;* into ascii format, with leading zero suppression.
;* Leading zeros are converted into space characters.
;* The flag ?NO_BLANK? starts cleared and is set once a non-zero
;* digit has been detected.
;* The ?units? digit is never blanked, even if it and all the
;* preceding digits are zero.
BCD2ASC           LDAA    #0            ; Initialize the blanking flag
                  STAA    NO_BLANK

C_TTHOU           LDAA    TEN_THOUS     ; Check... (6 KB left)
                  ORAA    NO_BLANK
                  BNE     NOT_BLANK1

ISBLANK1          LDAA    #' '          ; It?s blank
                  STAA    TEN_THOUS     ; so store a space
                  BRA     C_THOU        ; and check the ?thousands? digit

NOT_BLANK1        LDAA    TEN_THOUS     ; Get the ?ten_thousands? digit
                  ORAA    #$30          ; Convert to ascii
                  STAA    TEN_THOUS
                  LDAA    #$1           ; Signal that we have seen a ?non-blank? digit
                  STAA    NO_BLANK

C_THOU            LDAA    THOUSANDS     ; Check the thousands digit for blankness
                  ORAA    NO_BLANK      ; If it?s blank and ?no-blank? is still zero
                  BNE     NOT_BLANK2

ISBLANK2          LDAA    #' '          ; Thousands digit is blank
                  STAA    THOUSANDS     ; so store a space
                  BRA     C_HUNS        ; and check the hundreds digit

NOT_BLANK2        LDAA    THOUSANDS     ; (similar to ?ten_thousands? case)
                  ORAA    #$30
                  STAA    THOUSANDS
                  LDAA    #$1
                  STAA    NO_BLANK

C_HUNS            LDAA    HUNDREDS      ; Check the hundreds digit for blankness
                  ORAA    NO_BLANK      ; If it?s blank and ?no-blank? is still zero
                  BNE     NOT_BLANK3

ISBLANK3          LDAA    #' '          ; Hundreds digit is blank
                  STAA    HUNDREDS       ; so store a space
                  BRA     C_TENS          ; and check the tens digit

NOT_BLANK3        LDAA    HUNDREDS          ; (similar to ?ten_thousands? case)
                  ORAA    #$30
                  STAA    HUNDREDS
                  LDAA    #$1
                  STAA    NO_BLANK

C_TENS            LDAA    TENS          ; Check the tens digit for blankness
                  ORAA    NO_BLANK      ; If it?s blank and ?no-blank? is still zero
                  BNE     NOT_BLANK4

ISBLANK4          LDAA    #' '          ; Tens digit is blank
                  STAA    TENS          ; so store a space
                  BRA     C_UNITS       ; and check the units digit

NOT_BLANK4        LDAA    TENS          ; (similar to ?ten_thousands? case)
                  ORAA    #$30
                  STAA    TENS

C_UNITS           LDAA    UNITS         ; No blank check necessary, convert to ascii.
                  ORAA    #$30
                  STAA    UNITS
                  RTS                 ; We?re done

;***************************************************************************************************
;***************************************************************************************************
;*                                Interrupt Vectors                                                *
;***************************************************************************************************
                  ORG     $FFFE
                  DC.W    Entry ; Reset Vector
                  ORG     $FFDE
                  DC.W    TOF_ISR ; Timer Overflow Interrupt Vector